# JavaScript Execution

To truly understand `JavaScript` execution we must understand a few concepts. First of all, that JS holds a data store, this store is what we call the `Global Variable Environment (GVE)`, it is where we store all of our declarations in JS, or in more simplistic terms "Memory". This is opposed to our `Execution Context (EC)` it is available throughout our script throughout the whole time of our execution, unlike our `EC`s created when we run a function which store data inside the function itself which is lost upon the completion of the `EC`. Whatever terminology we may use, be it `declare`, `register`, `define`, `assign`, all mean the same thing, they mean <em>"Take the item and save it in memory"</em> or as a function <em>"Take the code, and it's arguments, don't execute it now, save it in memory for later"</em>, this terminology can be somewhat misleading as it suggests the `engine` is vaguely aware of the function at this point, however, it is not, JS does not "go back" to the line, it holds onto the data in memory to use when the function is run. In this sense we can think of a function as a means of bundling up code to run at a later time. This implies that any time we want to save code to run later we can simply wrap it in a function to attain this behaviour.

## Thread of Execution

We will begin by looking at an example in which we are going to follow the `thread of execution`. This is the method in which JS reads the code line-by-line, however, in doing so we will see just how JS is interacting with the `GVE`, later this will assist us in understanding how `Node` helps JS interact with the OS. Below is the code we will execute, this is an example from one of my favourite online lecturerers [Will Sentence](https://frontendmasters.com/courses/servers-node-js/executing-javascript-code-review/) who explains all of this in excrutiating detail with multiple series of videos covering the subject in differing contexts.

<pre>
<code>
    let num = 3;

    // Save the function to GVE
    function multiplyBy2 (inputNumber) {
        const result = inputNumber*2;
        return result;
    }

    // Invoke function and insert argument
    const output = multiplyBy2(num);
</code>
</pre>

We begin reading the code `lexically`, as such, we begin at the top just as JS does and our firstline: declaring a variable and assigning it a value of `3`. This is simple enough, I am pretty sure most of you have covered this already. The interesting part here is what actually happens under the hood when we write this, if you look at the `GVE` diagram below, you will see that upon execution a value is stored in the `GVE` with an assigned `label` and the `value` we assigned to it.

Not too difficult yet right? so what happens when we read the next line? this is where some more junior devs might get confused, it can be instinctive that because we are executing the script line-by-line that the function declaration will begin and start executing what is inside of the function. This is incorrect, at this point the `engine` does not care what is inside of this function, it sees the keyword function and saves the whole function to the `GVE`. This is JS `saving` the code for later, don't get confused, JS doesn't come back to this code, it doesn't somehow magically jump back up to here during execution, though in the `debugger` it can give this illusion, no, it saves this function to the `GVE`, including any variables packaged with it in the functions little backpack store, known as the `Persistent Lexical Scope Referenced Data ` which all functions in JS have (this is how `closures` work), of variables for later use, it is never coming back here, so it needs to make sure it has this saved.

We do not enter the function yet, we only enter a function after it has been `invoked` and, as we know, we invoke a function using parenthesese. Instead, we move down to our declaration of the `output` variable. In this we assign the output of a function call to multiplyBy2 passing the argument of the variable `num` which evaluates to `3`. Thus we actually end up with: `output = multiplyBy2(3)`. Now we have parenthesese on our function we have `invoked` the function `multiplyby2` with the argument `3`, what happens? in short, we open up a new `Execution Context` specifically a `Functional Execution Context`.

It can be useful to think of `Execution Contexts` as `Miniature Apps`, they still contain the two concepts we see within the `Global Execution Context`, the two main concepts of `JavaScript`:

- The Thread Of Execution
- The Global Variable Environment

These two things together build up the `Execution Context`. You can see the `Execution Context` within the below diagram as a min-terminal under the declaration which assigns the function. So, we enter the new `Execution Context`, what is the first thing we handle? the assignment of our `parameters` and `arguments` in local memory of course! notice our function has an `inputNumber` passed in, as we already stated, we know this will evaluate to `3`, in local memory we pass save this with the `parameter` (the `label`) on the left and the `argument` (the `value`) on the right, the `parameter` is named as such as it is merely a placeholder for our actual value, when the function is run it updates this in local memory to hold the `value` of our `argument`.

The next line, we set the result within the `function` to `inputValue*2`, we evaluate the calculation first, setting the `result` in memory to the value of `6`. Remember, this is being set in `LOCAL` memory, once the function exists this `Execution Context` all information stored here is lost. Thus, we come to our final line, the `return` statement, the `return` statement says to JS <em>"Locat ehte block of memory bound to the `label` result and return it out of the `function`"</em>, as such, our result evaluates to `6` and the evaluated output `6` is assigned to the `output` variable. Here you can see the `Thread of Execution` in action, we only have one thread, therefore, anytime we enter a function we must weave into said function, execute each line within that `context`, and then exit out to our outer `context`. As alluded to in the previous chapter this means we can only do one thing at a time in JS.

So, how does JS keep track of the `Execution Contexts` you ask? via the `Execution Context Stack` (AKA the `Call Stack`). The call stack initializes with the `Global Context` and then adds contexts to the top of the `stack` as they are created, running whatever happens to be atop of the stack at the time. This is also how JS hoisting works, allowing us to access variables from outer contexts, when finding a variable JS will check the initial `scope` first, but if it does not find a declaration in the immediately it can check the `outer` contexts to see if it exists there, if it reaches the `Global Context` and it is still undefined it will either declare a implicit value (undefined) or throw an error in strict mode. As soon as we hit `return` the item on the top of the call stack is popped off. The diagram indicates this by the greying out of the function on the callStack with the global context call being set in `blue`. These are the three key pillars of JS, the main concepts to grasp, it is important to reiterate that after these contexts `return` the only thing stored is the `returned` value, all `local memory` dies with the context.

<div align="center">
<img src="../images/jsExecutionbasic.png">
</div>

This all may seem like a lot to take in for something which, in practice, as actually very simple to understand, however, it is important to understand the completeness of communication when we discuss technical concepts. You will need to think and refine your knowledge over multiple iterations, even then, you will often find yourself using incorrect pharsology to describe concepts. While the difference between a "copy" and a "reference" may seem trivial, the terminology is important and requires some level of pedantry to understand the true process in it's entirety. For instance, should I ask you to describe the output of the above `FEC` you may be tempted to say something like "<em>It returns the output of `result` out</em>" while this may <em>seem</em> correct if we look at this as a detached statement we begin to see the flaws. Yes, the `return` statement does return a `value` to the outer context, but, it is important to understand that the `parameter` we have saved in local memory at this point is nought but a label, this is <strong>not</strong> returned to the `GEC`, it is but the `argument` that is returned. We would be far more accurate in stating this as such "<em>The `return` statement in the `Functional Exectuion Context` checks local memory for a `parameter` of `result` and returns the `argument` associated with it to the `Global Execution Context`.</em>" of course we also value completeness in this regard, thus it would be even better if we tacked onto the end: "<em>This is saved in the `Global Variable Environment`, the declared `output` variable is then assigned this result as an `evaluation` of the function call.</em>".

## Rules of Engagement

As a little break from the technicalities this is a good time to discuss the `philosophy` of programming. I like to consider computing as any other scientific field. We have a `theory`, and `philosophy` all and one the same, here we are joining both `theory` (the `how`) and `philosophy` (the `why` and `what if?`), these are two vaslty different, often `contentional` frames of view. It is important we understand both of these if we want to understand how things work, how to implement them, yes, this is `theory and practice`, but just as important is the `why`; the critical analysis and examinationt. When we `think` we must `vocalise`, it is thought around `80%` of conscious thought is not truly realised until we `vocalise` our thoughts, sometimes hearing them aloud tells us everything we need to know, sometimes it invites criticism, evaluation, and debate from others which help to refine our ideas and concepts. When we `think` critically, truly critically, a conversation plays out between two corresponding sides in our head. Each side analyses the argument of the other and attempts to break it, in such a case we become more than just ourselves but multiple entities vying for their ideas. When listening to the ideas of others we should do just that, listen, REALLY listen, and only when you are sure you have understood should you then attempt to forumlate a response. Multiple techniques can be incorporated to assist with this; repeating the question or argument back to the person who stated it for clarification, breaking down the statement and querying individual parts, clarifying the vocabulary and definitions used, stepping through the problem with the person from the very begginning. One piece of advice is, not matter what, never trust someone on their word alone, more so, never trust yourself on your word alone, you are devious, deceitful, you lie to yourself all the time, what makes you think you are not lying right now? as such, verify, verify everything to the nth degree, this really helps when debugging a complex application, make no assumptions. This can often frustrate others as you may often hear a resounding statement of "I already tried that!" as if astounded by your lack of trust, though, it is not lack of trust in them as a person per-se, nor is it a lack of trust in you should you find yourself thinking this, more so an understanding of the possibiltiy for human error from anyone no matter their level of seniority (we are all human after all). We must learn to see past these usual social niceities that we would normally place upon ourselves (and others) to really learn the truth; don't take anything for granted, even if it is promsied to be true, always be sure to verify it. To reiterate, always start debugging from the beginning of the problem, be clear in your definitions, and try to vai for completeness of concept in your own explanations (this one is especially difficult!).

Returning from our slight detour we must posture yet another query, what does it mean to `evaluate` something? in real-world terms an `evaluation` is the process of judging the quality of an item or service. This is not what we mean in computing, when we say something `evaluates` it essentially becomes the value, for instance, in the case of our diagram we have a line through `multiplyBy2` with a `6` above it, indicating it has `evaluated` to the value `6`, this is what will be assigned to our output, we are not assigning the function, but what the function `evaluates` to. Now, understand we can too assign functions to variables in JS, but in this case the parenthesese tell JS to run the function. Whenever we add parenthesese in JS the function will run, this is similarly how `Node` runs our callbacks which we will look into more in further in later chapters.